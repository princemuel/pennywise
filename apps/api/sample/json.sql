-- ============================================================================
-- IDENTITY & AUTH (separate from user profile)
-- ============================================================================
CREATE TABLE USERS (
    ID UUID PRIMARY KEY DEFAULT gen_random_uuid_v7(),
    EMAIL TEXT UNIQUE NOT NULL CHECK (
        EMAIL ~* '^[A-Za-z0-9._%+-]+@[A-Za-z0-9.-]+\.[A-Za-z]{2,}$'
    ),
    EMAIL_VERIFIED_AT TIMESTAMPTZ,
    DISPLAY_NAME TEXT NOT NULL,
    TIMEZONE TEXT NOT NULL DEFAULT 'UTC',
    CURRENCY TEXT NOT NULL DEFAULT 'USD' CHECK (CURRENCY ~ '^[A-Z]{3}$'),
    LOCALE TEXT NOT NULL DEFAULT 'en_US',
    CREATED_AT TIMESTAMPTZ NOT NULL DEFAULT NOW(),
    UPDATED_AT TIMESTAMPTZ NOT NULL DEFAULT NOW(),
    DISABLED_AT TIMESTAMPTZ
);
-- Auth credentials (multiple login methods per user)
CREATE TABLE AUTH_CREDENTIALS (
    ID UUID PRIMARY KEY DEFAULT gen_random_uuid_v7(),
    USER_ID UUID NOT NULL REFERENCES USERS(ID) ON DELETE CASCADE ON UPDATE CASCADE,
    PROVIDER TEXT NOT NULL,
    -- 'email', 'google', 'github'
    PROVIDER_USER_ID TEXT,
    PASSWORD_HASH TEXT,
    -- NULL for OAuth
    CREATED_AT TIMESTAMPTZ NOT NULL DEFAULT NOW(),
    LAST_USED_AT TIMESTAMPTZ,
    UNIQUE(PROVIDER, PROVIDER_USER_ID)
);
CREATE INDEX IDX_AUTH_USER ON AUTH_CREDENTIALS(USER_ID);
CREATE INDEX IDX_AUTH_PROVIDER_USER ON AUTH_CREDENTIALS(PROVIDER_USER_ID);
-- Optional: session storage if using NextAuth DB mode
CREATE TABLE SESSIONS (
    ID UUID PRIMARY KEY DEFAULT gen_random_uuid_v7(),
    USER_ID UUID NOT NULL REFERENCES USERS(ID) ON DELETE CASCADE ON UPDATE CASCADE,
    EXPIRES_AT TIMESTAMPTZ NOT NULL,
    SESSION_TOKEN TEXT UNIQUE NOT NULL,
    CREATED_AT TIMESTAMPTZ NOT NULL DEFAULT NOW(),
    LAST_ACTIVITY_AT TIMESTAMPTZ NOT NULL DEFAULT NOW()
);
CREATE INDEX IDX_SESSIONS_USER ON SESSIONS(USER_ID);
CREATE INDEX IDX_SESSIONS_TOKEN ON SESSIONS(SESSION_TOKEN);
CREATE INDEX IDX_SESSIONS_EXPIRES ON SESSIONS(EXPIRES_AT);
-- ============================================================================
-- ACCOUNTS (containers, not balances)
-- ============================================================================
CREATE TYPE ACCOUNT_TYPE AS ENUM (
    'checking',
    'savings',
    'credit',
    'cash',
    'investment'
);
CREATE TABLE ACCOUNTS (
    ID UUID PRIMARY KEY DEFAULT gen_random_uuid_v7(),
    USER_ID UUID NOT NULL REFERENCES USERS(ID) ON DELETE CASCADE ON UPDATE CASCADE,
    NAME TEXT NOT NULL,
    ACCOUNT_TYPE ACCOUNT_TYPE NOT NULL,
    CURRENCY_CODE CHAR(3) NOT NULL DEFAULT 'USD' CHECK (CURRENCY_CODE ~ '^[A-Z]{3}$'),
    INSTITUTION_NAME TEXT,
    ACCOUNT_NUMBER_LAST4 TEXT,
    OPENED_AT DATE,
    CLOSED_AT DATE,
    METADATA JSONB,
    CREATED_AT TIMESTAMPTZ NOT NULL DEFAULT NOW(),
    UPDATED_AT TIMESTAMPTZ NOT NULL DEFAULT NOW()
);
CREATE INDEX IDX_ACCOUNTS_USER ON ACCOUNTS(USER_ID);
CREATE INDEX IDX_ACCOUNTS_OPEN ON ACCOUNTS(USER_ID, CLOSED_AT)
WHERE CLOSED_AT IS NULL;
CREATE INDEX IDX_ACCOUNTS_METADATA_GIN ON ACCOUNTS USING gin(METADATA);
COMMENT ON TABLE ACCOUNTS IS 'Accounts are containers. Balance is derived from entries.';
COMMENT ON COLUMN ACCOUNTS.METADATA IS 'Bank sync data, connection status, etc.';
-- ============================================================================
-- LEDGER (the heart of the system)
-- ============================================================================
CREATE TABLE TRANSACTIONS (
    ID UUID PRIMARY KEY DEFAULT gen_random_uuid_v7(),
    USER_ID UUID NOT NULL REFERENCES USERS(ID) ON DELETE CASCADE ON UPDATE CASCADE,
    OCCURRED_AT TIMESTAMPTZ NOT NULL,
    DESCRIPTION TEXT,
    SOURCE TEXT NOT NULL DEFAULT 'manual',
    -- 'manual', 'import', 'api', 'recurring'
    CREATED_AT TIMESTAMPTZ NOT NULL DEFAULT NOW(),
    UPDATED_AT TIMESTAMPTZ NOT NULL DEFAULT NOW()
);
CREATE INDEX IDX_TRANSACTIONS_USER ON TRANSACTIONS(USER_ID);
CREATE INDEX IDX_TRANSACTIONS_OCCURRED ON TRANSACTIONS(OCCURRED_AT DESC);
CREATE TABLE TRANSACTION_ENTRIES (
    ID UUID PRIMARY KEY DEFAULT gen_random_uuid_v7(),
    TRANSACTION_ID UUID NOT NULL REFERENCES TRANSACTIONS(ID) ON DELETE CASCADE ON UPDATE CASCADE,
    ACCOUNT_ID UUID NOT NULL REFERENCES ACCOUNTS(ID) ON DELETE RESTRICT ON UPDATE CASCADE,
    CATEGORY_ID UUID REFERENCES CATEGORIES(ID) ON DELETE
    SET NULL ON UPDATE CASCADE,
        AMOUNT DECIMAL(19, 4) NOT NULL,
        NOTES TEXT,
        CREATED_AT TIMESTAMPTZ NOT NULL DEFAULT NOW(),
        UPDATED_AT TIMESTAMPTZ NOT NULL DEFAULT NOW(),
        CONSTRAINT AMOUNT_NOT_ZERO CHECK (AMOUNT != 0)
);
CREATE INDEX IDX_ENTRIES_TRANSACTION ON TRANSACTION_ENTRIES(TRANSACTION_ID);
CREATE INDEX IDX_ENTRIES_ACCOUNT ON TRANSACTION_ENTRIES(ACCOUNT_ID);
CREATE INDEX IDX_ENTRIES_CATEGORY ON TRANSACTION_ENTRIES(CATEGORY_ID);
COMMENT ON TABLE TRANSACTIONS IS 'Represents a real-world event (payment, transfer, etc.)';
COMMENT ON TABLE TRANSACTION_ENTRIES IS 'Double-entry ledger. One transaction can have multiple entries.';
-- ============================================================================
-- CATEGORIES (hierarchical, user-owned)
-- ============================================================================
CREATE TYPE CATEGORY_KIND AS ENUM ('income', 'expense', 'transfer');
CREATE TABLE CATEGORIES (
    ID UUID PRIMARY KEY DEFAULT gen_random_uuid_v7(),
    USER_ID UUID REFERENCES USERS(ID) ON DELETE CASCADE ON UPDATE CASCADE,
    PARENT_ID UUID REFERENCES CATEGORIES(ID) ON DELETE
    SET NULL ON UPDATE CASCADE,
        NAME TEXT NOT NULL,
        KIND CATEGORY_KIND NOT NULL,
        ARCHIVED_AT TIMESTAMPTZ,
        CREATED_AT TIMESTAMPTZ NOT NULL DEFAULT NOW(),
        UPDATED_AT TIMESTAMPTZ NOT NULL DEFAULT NOW()
);
CREATE INDEX IDX_CATEGORIES_USER ON CATEGORIES(USER_ID);
CREATE INDEX IDX_CATEGORIES_PARENT ON CATEGORIES(PARENT_ID);
CREATE INDEX IDX_CATEGORIES_ACTIVE ON CATEGORIES(USER_ID, ARCHIVED_AT)
WHERE ARCHIVED_AT IS NULL;
COMMENT ON COLUMN CATEGORIES.USER_ID IS 'NULL for system categories, user_id for custom';
-- ============================================================================
-- BUDGETS (rules, not containers)
-- ============================================================================
CREATE TYPE BUDGET_PERIOD AS ENUM ('weekly', 'monthly', 'quarterly', 'yearly');
CREATE TYPE BUDGET_SCOPE_TYPE AS ENUM ('category', 'account');
CREATE TABLE BUDGETS (
    ID UUID PRIMARY KEY DEFAULT gen_random_uuid_v7(),
    USER_ID UUID NOT NULL REFERENCES USERS(ID) ON DELETE CASCADE ON UPDATE CASCADE,
    SCOPE_TYPE BUDGET_SCOPE_TYPE NOT NULL,
    SCOPE_ID UUID NOT NULL,
    PERIOD BUDGET_PERIOD NOT NULL,
    LIMIT_AMOUNT DECIMAL(19, 4) NOT NULL,
    CURRENCY_CODE CHAR(3) NOT NULL CHECK (CURRENCY_CODE ~ '^[A-Z]{3}$'),
    STARTS_ON DATE NOT NULL,
    ENDS_ON DATE,
    ROLLOVER BOOLEAN NOT NULL DEFAULT FALSE,
    ALERT_THRESHOLD DECIMAL(5, 2),
    CREATED_AT TIMESTAMPTZ NOT NULL DEFAULT NOW(),
    UPDATED_AT TIMESTAMPTZ NOT NULL DEFAULT NOW(),
    CONSTRAINT POSITIVE_LIMIT CHECK (LIMIT_AMOUNT > 0),
    CONSTRAINT VALID_THRESHOLD CHECK (
        ALERT_THRESHOLD IS NULL
        OR (
            ALERT_THRESHOLD > 0
            AND ALERT_THRESHOLD <= 100
        )
    )
);
CREATE INDEX IDX_BUDGETS_USER ON BUDGETS(USER_ID);
CREATE INDEX IDX_BUDGETS_PERIOD ON BUDGETS(STARTS_ON, ENDS_ON);
COMMENT ON TABLE BUDGETS IS 'Budgets are constraints over time, not containers';
-- ============================================================================
-- GOALS (mental accounting)
-- ============================================================================
CREATE TYPE GOAL_STATUS AS ENUM ('active', 'completed', 'abandoned');
CREATE TABLE GOALS (
    ID UUID PRIMARY KEY DEFAULT gen_random_uuid_v7(),
    USER_ID UUID NOT NULL REFERENCES USERS(ID) ON DELETE CASCADE ON UPDATE CASCADE,
    NAME TEXT NOT NULL,
    TARGET_AMOUNT DECIMAL(19, 4) NOT NULL,
    CURRENCY_CODE CHAR(3) NOT NULL CHECK (CURRENCY_CODE ~ '^[A-Z]{3}$'),
    TARGET_DATE DATE,
    STATUS GOAL_STATUS NOT NULL DEFAULT 'active',
    CREATED_AT TIMESTAMPTZ NOT NULL DEFAULT NOW(),
    UPDATED_AT TIMESTAMPTZ NOT NULL DEFAULT NOW(),
    COMPLETED_AT TIMESTAMPTZ,
    CONSTRAINT POSITIVE_TARGET CHECK (TARGET_AMOUNT > 0)
);
CREATE INDEX IDX_GOALS_USER ON GOALS(USER_ID);
CREATE INDEX IDX_GOALS_ACTIVE ON GOALS(USER_ID, STATUS)
WHERE STATUS = 'active';
-- Goal allocations
CREATE TABLE GOAL_ALLOCATIONS (
    ID UUID PRIMARY KEY DEFAULT gen_random_uuid_v7(),
    GOAL_ID UUID NOT NULL REFERENCES GOALS(ID) ON DELETE CASCADE ON UPDATE CASCADE,
    TRANSACTION_ENTRY_ID UUID NOT NULL REFERENCES TRANSACTION_ENTRIES(ID) ON DELETE CASCADE ON UPDATE CASCADE,
    AMOUNT DECIMAL(19, 4) NOT NULL,
    CREATED_AT TIMESTAMPTZ NOT NULL DEFAULT NOW(),
    CONSTRAINT POSITIVE_ALLOCATION CHECK (AMOUNT > 0),
    UNIQUE(GOAL_ID, TRANSACTION_ENTRY_ID)
);
CREATE INDEX IDX_ALLOCATIONS_GOAL ON GOAL_ALLOCATIONS(GOAL_ID);
COMMENT ON TABLE GOAL_ALLOCATIONS IS 'Links transaction entries to savings goals';
-- ============================================================================
-- RECURRING RULES (not booleans)
-- ============================================================================
CREATE TYPE RECURRENCE_CADENCE AS ENUM (
    'daily',
    'weekly',
    'biweekly',
    'monthly',
    'quarterly',
    'yearly'
);
CREATE TABLE RECURRING_RULES (
    ID UUID PRIMARY KEY DEFAULT gen_random_uuid_v7(),
    USER_ID UUID NOT NULL REFERENCES USERS(ID) ON DELETE CASCADE ON UPDATE CASCADE,
    CADENCE RECURRENCE_CADENCE NOT NULL,
    AMOUNT DECIMAL(19, 4) NOT NULL,
    ACCOUNT_ID UUID NOT NULL REFERENCES ACCOUNTS(ID) ON DELETE CASCADE ON UPDATE CASCADE,
    CATEGORY_ID UUID REFERENCES CATEGORIES(ID) ON DELETE
    SET NULL ON UPDATE CASCADE,
        DESCRIPTION TEXT NOT NULL,
        NEXT_RUN_AT DATE NOT NULL,
        END_AT DATE,
        ACTIVE BOOLEAN NOT NULL DEFAULT TRUE,
        AUTO_CREATE BOOLEAN NOT NULL DEFAULT FALSE,
        CREATED_AT TIMESTAMPTZ NOT NULL DEFAULT NOW(),
        UPDATED_AT TIMESTAMPTZ NOT NULL DEFAULT NOW()
);
CREATE INDEX IDX_RECURRING_USER ON RECURRING_RULES(USER_ID);
CREATE INDEX IDX_RECURRING_NEXT ON RECURRING_RULES(NEXT_RUN_AT)
WHERE ACTIVE = TRUE;
COMMENT ON TABLE RECURRING_RULES IS 'Drives forecasts, reminders, auto-posting';
-- ============================================================================
-- VIEWS (derived data)
-- ============================================================================
-- Account balances (derived from entries)
-- Optional: materialized view for performance
-- CREATE MATERIALIZED VIEW MV_ACCOUNT_BALANCES AS
CREATE OR REPLACE VIEW V_ACCOUNT_BALANCES AS
SELECT A.ID AS ACCOUNT_ID,
    A.USER_ID,
    A.NAME,
    A.ACCOUNT_TYPE,
    A.CURRENCY_CODE,
    COALESCE(SUM(E.AMOUNT), 0) AS BALANCE
FROM ACCOUNTS A
    LEFT JOIN TRANSACTION_ENTRIES E ON E.ACCOUNT_ID = A.ID
WHERE A.CLOSED_AT IS NULL
GROUP BY A.ID,
    A.USER_ID,
    A.NAME,
    A.ACCOUNT_TYPE,
    A.CURRENCY_CODE;
-- Current month spending by category
CREATE OR REPLACE VIEW V_CURRENT_MONTH_SPENDING AS
SELECT E.ACCOUNT_ID,
    TE.USER_ID,
    C.ID AS CATEGORY_ID,
    C.NAME AS CATEGORY_NAME,
    SUM(ABS(E.AMOUNT)) AS TOTAL_SPENT,
    COUNT(*) AS TRANSACTION_COUNT
FROM TRANSACTION_ENTRIES E
    JOIN TRANSACTIONS TE ON TE.ID = E.TRANSACTION_ID
    JOIN CATEGORIES C ON C.ID = E.CATEGORY_ID
WHERE DATE_TRUNC('month', TE.OCCURRED_AT) = DATE_TRUNC('month', CURRENT_DATE)
    AND E.AMOUNT < 0
GROUP BY E.ACCOUNT_ID,
    TE.USER_ID,
    C.ID,
    C.NAME;
-- Goal progress
CREATE OR REPLACE VIEW V_GOAL_PROGRESS AS
SELECT G.ID AS GOAL_ID,
    G.USER_ID,
    G.NAME,
    G.TARGET_AMOUNT,
    COALESCE(SUM(GA.AMOUNT), 0) AS CURRENT_AMOUNT,
    G.TARGET_AMOUNT - COALESCE(SUM(GA.AMOUNT), 0) AS REMAINING,
    CASE
        WHEN G.TARGET_AMOUNT > 0 THEN (
            COALESCE(SUM(GA.AMOUNT), 0) / G.TARGET_AMOUNT * 100
        )
        ELSE 0
    END AS PERCENTAGE_COMPLETE
FROM GOALS G
    LEFT JOIN GOAL_ALLOCATIONS GA ON GA.GOAL_ID = G.ID
WHERE G.STATUS = 'active'
GROUP BY G.ID,
    G.USER_ID,
    G.NAME,
    G.TARGET_AMOUNT;
